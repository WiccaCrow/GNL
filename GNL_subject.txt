
Получить следующую строку

Чтение строки на fd слишком утомительно



_______________________________

Содержание

I цели ................................... 2
II Общие инструкции ...................... 3
III Обязательная часть - Get_next_line ... 4
IV Бонус, часть .......................... 6

_______________________________

Глава I Цели

Этот проект не только позволит вам добавить очень удобную функцию в вашу коллекцию, но также позволит вам изучить очень интересную новую концепцию программирования на C: статические переменные.

_______________________________

Глава II.

Общие инструкции

• Ваш проект должен быть написан в соответствии с Нормой. Если у вас есть бонусные файлы / функции, они включены в проверку нормы, и вы получите 0, если внутри есть ошибка нормы.

• Ваши функции не должны завершаться неожиданно (ошибка сегментации, ошибка шины, двойное освобождение и т.д.), за исключением неопределенного поведения. Если это произойдет, ваш проект будет считаться нефункциональным и получит 0 во время оценки.

• Все пространство памяти, выделенное кучей, должно быть должным образом освобождено при необходимости. Никакие утечки недопустимы.

• Если субъект требует этого, вы должны отправить Makefile, который скомпилирует ваши исходные файлы в требуемый вывод с флагами -Wall, -Wextra и -Werror, и ваш Makefile не должен повторно связываться.

• Ваш Makefile должен содержать как минимум правила $ (NAME), all, clean, fclean и re.

• Чтобы получить бонусы для вашего проекта, вы должны включить бонус правила в свой Makefile, который добавит все различные заголовки, библиотеки или функции, запрещенные в основной части проекта. Бонусы должны быть в другом файле _bonus. {C / h}. Оценка обязательной и бонусной части проводится отдельно.

• Если ваш проект позволяет вам использовать ваш libft, вы должны скопировать его исходный код и связанный с ним Makefile в папку libft с соответствующим Makefile. Makefile вашего проекта должен скомпилировать библиотеку, используя свой Makefile, а затем скомпилировать проект.

• Мы рекомендуем вам создавать программы тестирования для вашего проекта, даже если эту работу не нужно будет отправлять и оценивать. Это даст вам возможность легко проверить свою работу и работу ваших коллег. Вы найдете эти тесты особенно полезными во время защиты. Действительно, во время защиты вы можете использовать свои тесты и / или тесты партнера, которого вы оцениваете.

• Отправьте свою работу в назначенный репозиторий git. Оцениваться будет только работа в репозитории git. Если DeepThreadt назначен для оценки вашей работы, это будет сделано после ваших оценок коллег. Если во время выставления оценок Deepoughtt в каком-либо разделе вашей работы произойдет ошибка, оценка остановится.

______________________________________

Глава III.

Обязательная часть - Get_next_line

___________________________________________________________________
Название функции      |    get_next_line
______________________|____________________________________________
Прототип              | int get_next_line (int fd, char ** строка);
______________________|____________________________________________
Сдаваемые файлы.      |     get_next_line.c, 
		      |     get_next_line_utils.c,
		      |     get_next_line.h
______________________|____________________________________________
Параметры 	      |     №1. файловый дескриптор для чтения
		      |     №2. Значение прочитанного
______________________|____________________________________________
Возвращаемое значение |	     1: строка была прочитана
		      |      0: EOF достигнут
		      |     -1: произошла ошибка    
______________________|____________________________________________
Внешние функции.      | read, malloc, free
______________________|____________________________________________
Описание              |   Напишите функцию, которая возвращает строку, 
		      |   прочитанную из файлового дескриптора, без 
		      |   новой строки.
______________________|____________________________________________

 Вызов вашей функции get_next_line в цикле позволит вам прочитать текст, доступный в файловом дескрипторе, по одной строке за раз до EOF.

• Убедитесь, что ваша функция хорошо себя ведет при чтении из файла и при чтении из стандартного ввода.

• libft не разрешена для этого проекта. Вы должны добавить файл get_next_line_utils.c, который будет содержать функции, необходимые для работы get_next_line.

• Ваша программа должна компилироваться с флагом -D BUFFER_SIZE = xx. который будет использоваться в качестве размера буфера для вызовов чтения в вашем get_next_line. Это значение будет изменено вашими оценщиками и муленеттом.

• Компиляция будет выполняться следующим образом: gcc -Wall -Wextra -Werror -D BUFFER_SIZE = 32 get_next_line.c get_next_line_utils.c

• Ваше чтение должно использовать BUFFER_SIZE, определенный во время компиляции, для чтения из файла или из стандартного ввода.

• В заголовочном файле get_next_line.h у вас должен быть как минимум прототип функции get_next_line.

______________________________________________________________________
Ваша функция по-прежнему работает, если значение BUFFER_SIZE равно 9999? А если значение BUFFER_SIZE равно 1? А 10000000? Ты знаешь почему?
______________________________________________________________________ 
  Вы должны стараться читать как можно меньше при каждом вызове get_next_line. Если вы встретили новую строку, вам нужно вернуть текущую строку. Не читайте файл целиком, а затем обрабатывайте каждую строку.
______________________________________________________________________ 
Не сдавайте свой проект без тестирования. Есть много тестов, которые нужно запустить, охватите свои базы. Попробуйте прочитать из файла, из перенаправления, из стандартного ввода. Как ведет себя ваша программа, когда вы отправляете
перевод строки в стандартный вывод? А CTRL-D?
______________________________________________________________________

• Мы считаем, что get_next_line имеет неопределенное поведение, если между двумя вызовами один и тот же файловый дескриптор переключается на другой файл до того, как EOF был достигнут на первом fd.

• lseek - недопустимая функция. Чтение файла необходимо производить только один раз.

• Наконец, мы считаем, что get_next_line имеет неопределенное поведение при чтении из двоичного файла. Однако при желании вы можете сделать такое поведение последовательным.

• Глобальные переменные запрещены.


______________________________________________________________________
______________________________________________________________________

Глава IV.

Бонусная часть

Проект get_next_line прост и оставляет очень мало места для бонусов, но я уверен, что у вас много воображения. Если вы успешно прошли обязательную часть, непременно выполните эту бонусную часть, чтобы продолжить. Повторяю, бонус не будет учитываться, если обязательная часть не идеальна.

Сдать все 3 исходных файла с _bonus для этой части.

• Чтобы добиться успеха в get_next_line с единственной статической переменной.

• Чтобы иметь возможность управлять несколькими файловыми дескрипторами с помощью get_next_line. Например, если файловые дескрипторы 3, 4 и 5 доступны для чтения, то вы можете вызвать get_next_line один раз на 3, один раз на 4, еще раз на 3, затем еще раз на 5 и т. Д. Без потери потока чтения на каждом из дескрипторы.
Glava IV.


